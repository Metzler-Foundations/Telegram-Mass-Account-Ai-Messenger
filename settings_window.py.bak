#!/usr/bin/env python3
"""
Settings Window - Configuration interface for the Telegram bot
"""

import logging
import os
import json
from typing import Dict, Any, Optional, List
from pathlib import Path
import requests

from PyQt6.QtWidgets import (
    QDialog, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QPushButton, QLineEdit, QTextEdit, QComboBox,
    QSpinBox, QDoubleSpinBox, QCheckBox, QGroupBox, QTabWidget,
    QScrollArea, QMessageBox, QFileDialog, QListWidget,
    QListWidgetItem, QProgressBar, QInputDialog, QFrame
)
from PyQt6.QtCore import Qt, pyqtSignal, QTimer
from PyQt6.QtGui import QIcon, QFont

logger = logging.getLogger(__name__)


class SettingsWindow(QDialog):
    """Settings dialog for configuring the Telegram bot."""

    settings_updated = pyqtSignal(dict)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Settings - Telegram Auto-Reply Bot")
        self.resize(900, 700)
        self.settings_data = {}
        self.load_settings()

        # Apply Discord theme
        self.apply_discord_theme()

        self.setup_ui()
        self.load_ui_from_settings()

    def apply_discord_theme(self):
        """Apply Discord-like dark theme."""
        try:
            from ui_redesign import DISCORD_THEME
            self.setStyleSheet(DISCORD_THEME)
        except ImportError:
            logger.warning("Could not import Discord theme")

    def setup_ui(self):
        """Set up the user interface."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(20, 20, 20, 20)
        layout.setSpacing(10)

        # Title
        title_label = QLabel("‚öôÔ∏è Bot Configuration")
        title_label.setObjectName("page_title")
        layout.addWidget(title_label)

        # Subtitle
        subtitle_label = QLabel("Configure API keys, account creation, anti-detection, and advanced features.")
        subtitle_label.setObjectName("page_subtitle")
        layout.addWidget(subtitle_label)

        # Tab widget
        self.tab_widget = QTabWidget()
        self.tab_widget.setObjectName("settings_tabs")
        layout.addWidget(self.tab_widget)

        # Create tabs
        self.create_api_tab()
        self.create_brain_tab()
        self.create_anti_detection_tab()
        self.create_member_scraper_tab()
        self.create_account_creator_tab()
        self.create_advanced_tab()

        # Buttons
        button_layout = QHBoxLayout()

        save_button = QPushButton("üíæ Save Settings")
        save_button.clicked.connect(self.save_settings)
        save_button.setObjectName("success")
        button_layout.addWidget(save_button)

        test_button = QPushButton("üß™ Test Configuration")
        test_button.clicked.connect(self.test_configuration)
        button_layout.addWidget(test_button)

        cancel_button = QPushButton("‚ùå Cancel")
        cancel_button.clicked.connect(self.reject)
        cancel_button.setObjectName("secondary")
        button_layout.addWidget(cancel_button)

        button_layout.addStretch()
        layout.addLayout(button_layout)

    def create_api_tab(self) -> QWidget:
        """Create the API & Auth tab."""
        content = self._create_tab_content_widget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(16)

        # Telegram API section
        telegram_group = QGroupBox("Telegram API Credentials")
        telegram_layout = QFormLayout()

        self.api_id_edit = QLineEdit()
        self.api_id_edit.setPlaceholderText("Your Telegram API ID")
        telegram_layout.addRow("API ID:", self.api_id_edit)

        self.api_hash_edit = QLineEdit()
        self.api_hash_edit.setPlaceholderText("Your Telegram API Hash")
        self.api_hash_edit.setEchoMode(QLineEdit.EchoMode.Password)
        telegram_layout.addRow("API Hash:", self.api_hash_edit)

        self.phone_number_edit = QLineEdit()
        self.phone_number_edit.setPlaceholderText("+1234567890")
        telegram_layout.addRow("Phone Number:", self.phone_number_edit)

        telegram_group.setLayout(telegram_layout)
        layout.addWidget(telegram_group)

        # Gemini API section
        gemini_group = QGroupBox("Gemini AI API")
        gemini_layout = QFormLayout()

        self.gemini_api_edit = QLineEdit()
        self.gemini_api_edit.setPlaceholderText("Your Gemini API key")
        self.gemini_api_edit.setEchoMode(QLineEdit.EchoMode.Password)
        gemini_layout.addRow("API Key:", self.gemini_api_edit)

        gemini_group.setLayout(gemini_layout)
        layout.addWidget(gemini_group)

        layout.addStretch()
        return self._wrap_tab(content, "API & Auth", "Configure API credentials and authentication settings.")

    def create_brain_tab(self) -> QWidget:
        """Create the Brain & Behavior tab."""
        content = self._create_tab_content_widget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(16)

        # AI Configuration
        ai_group = QGroupBox("AI Configuration")
        ai_layout = QFormLayout()

        self.prompt_edit = QTextEdit()
        self.prompt_edit.setPlaceholderText("You are a helpful assistant...")
        self.prompt_edit.setMaximumHeight(120)
        ai_layout.addRow("System Prompt:", self.prompt_edit)

        self.auto_reply_checkbox = QCheckBox("Enable automatic replies")
        self.auto_reply_checkbox.setChecked(True)
        ai_layout.addRow(self.auto_reply_checkbox)

        self.typing_delay_spin = QSpinBox()
        self.typing_delay_spin.setRange(0, 10)
        self.typing_delay_spin.setValue(2)
        self.typing_delay_spin.setSuffix(" seconds")
        ai_layout.addRow("Typing delay:", self.typing_delay_spin)

        ai_group.setLayout(ai_layout)
        layout.addWidget(ai_group)

        layout.addStretch()
        return self._wrap_tab(content, "Brain & Behavior", "Configure AI responses and behavioral patterns.")

    def create_anti_detection_tab(self) -> QWidget:
        """Create the Anti-Detection tab."""
        content = self._create_tab_content_widget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(16)

        # Timing settings
        timing_group = QGroupBox("Timing & Delays")
        timing_layout = QFormLayout()

        self.min_delay_spin = QSpinBox()
        self.min_delay_spin.setRange(1, 60)
        self.min_delay_spin.setValue(2)
        self.min_delay_spin.setSuffix(" seconds")
        timing_layout.addRow("Minimum delay:", self.min_delay_spin)

        self.max_delay_spin = QSpinBox()
        self.max_delay_spin.setRange(5, 300)
        self.max_delay_spin.setValue(30)
        self.max_delay_spin.setSuffix(" seconds")
        timing_layout.addRow("Maximum delay:", self.max_delay_spin)

        self.messages_per_hour_spin = QSpinBox()
        self.messages_per_hour_spin.setRange(1, 100)
        self.messages_per_hour_spin.setValue(50)
        timing_layout.addRow("Messages per hour:", self.messages_per_hour_spin)

        timing_group.setLayout(timing_layout)
        layout.addWidget(timing_group)

        # Online simulation
        simulation_group = QGroupBox("Online Simulation")
        simulation_layout = QVBoxLayout()

        self.online_simulation_checkbox = QCheckBox("Simulate online presence")
        self.online_simulation_checkbox.setChecked(True)
        simulation_layout.addWidget(self.online_simulation_checkbox)

        self.random_skip_checkbox = QCheckBox("Randomly skip some messages")
        self.random_skip_checkbox.setChecked(True)
        simulation_layout.addWidget(self.random_skip_checkbox)

        simulation_group.setLayout(simulation_layout)
        layout.addWidget(simulation_group)

        layout.addStretch()
        return self._wrap_tab(content, "Anti-Detection", "Configure anti-detection measures and behavioral simulation.")

    def create_member_scraper_tab(self) -> QWidget:
        """Create the member scraper tab."""
        content = self._create_tab_content_widget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(16)

        description = QLabel(
            "Scrape members from public channels, monitor activity, and queue prospects for campaigns."
        )
        description.setWordWrap(True)
        layout.addWidget(description)

        # Channel Input Section
        input_group = QGroupBox("Channel/Group Input")
        input_layout = QVBoxLayout()

        # URL input
        url_layout = QHBoxLayout()
        self.channel_url_edit = QLineEdit()
        self.channel_url_edit.setPlaceholderText("https://t.me/channelname or @channelname or channelname")
        url_layout.addWidget(QLabel("Channel URL/ID:"))
        url_layout.addWidget(self.channel_url_edit)

        input_layout.addLayout(url_layout)

        # Control buttons
        button_layout = QHBoxLayout()

        self.scrape_button = QPushButton("Scrape Members")
        self.scrape_button.clicked.connect(self.scrape_channel_members)
        self.scrape_button.setObjectName("secondary")
        button_layout.addWidget(self.scrape_button)

        self.stop_scrape_button = QPushButton("Stop Scraping")
        self.stop_scrape_button.clicked.connect(self.stop_scraping)
        self.stop_scrape_button.setEnabled(False)
        self.stop_scrape_button.setObjectName("secondary")
        button_layout.addWidget(self.stop_scrape_button)

        input_layout.addLayout(button_layout)

        # Progress indicator
        self.scrape_progress = QProgressBar()
        self.scrape_progress.setVisible(False)
        self.scrape_progress.setFormat("Scraping members: %v found")
        input_layout.addWidget(self.scrape_progress)

        input_group.setLayout(input_layout)
        layout.addWidget(input_group)

        # Results Section
        results_group = QGroupBox("Scraping Results")
        results_layout = QVBoxLayout()

        # Results display
        self.scraper_results_text = QTextEdit()
        self.scraper_results_text.setReadOnly(True)
        self.scraper_results_text.setMaximumHeight(200)
        results_layout.addWidget(self.scraper_results_text)

        # Channel stats
        stats_layout = QHBoxLayout()
        self.stats_total = QLabel("Total: 0")
        self.stats_active = QLabel("Active: 0")
        self.stats_inactive = QLabel("Inactive: 0")

        stats_layout.addWidget(self.stats_total)
        stats_layout.addWidget(self.stats_active)
        stats_layout.addWidget(self.stats_inactive)
        stats_layout.addStretch()

        results_layout.addLayout(stats_layout)

        results_group.setLayout(results_layout)
        layout.addWidget(results_group)

        # Member Management Section
        manage_group = QGroupBox("Member Management")
        manage_layout = QVBoxLayout()

        # Channel selection
        channel_layout = QHBoxLayout()
        self.channel_select = QComboBox()
        self.channel_select.addItem("Select Channel...")
        channel_layout.addWidget(QLabel("Channel:"))
        channel_layout.addWidget(self.channel_select)

        manage_layout.addLayout(channel_layout)

        # Member list
        self.members_list = QListWidget()
        self.members_list.setMaximumHeight(150)
        manage_layout.addWidget(self.members_list)

        # Member actions
        action_layout = QHBoxLayout()

        self.refresh_members_button = QPushButton("Refresh List")
        self.refresh_members_button.clicked.connect(self.refresh_members)
        self.refresh_members_button.setObjectName("secondary")
        action_layout.addWidget(self.refresh_members_button)

        self.message_member_button = QPushButton("Message Selected")
        self.message_member_button.clicked.connect(self.message_selected_member)
        self.message_member_button.setObjectName("secondary")
        action_layout.addWidget(self.message_member_button)

        manage_layout.addLayout(action_layout)

        manage_group.setLayout(manage_layout)
        layout.addWidget(manage_group)

        layout.addStretch()

        # Store reference to main window for member operations
        self._main_window = self.parent()

        # Initialize parent reference if not set
        if not hasattr(self, '_main_window') or not self._main_window:
            # Try to get from parent
            parent = self.parent()
            if parent:
                self._main_window = parent

        return self._wrap_tab(content, "Member Intelligence", "Pull fresh audiences, audit engagement, and push prospects into messaging pipelines.")

    def create_account_creator_tab(self) -> QWidget:
        """Create the account creator tab."""
        content = self._create_tab_content_widget()
        layout = QVBoxLayout(content)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(16)

        info_label = QLabel(
            "Connect a phone-number API provider once and let the automation engine purchase numbers, "
            "verify OTPs, and warm up each account with safe anti-detection pacing."
        )
        info_label.setWordWrap(True)
        layout.addWidget(info_label)

        # Bulk Creation Section
        bulk_group = QGroupBox("Bulk Account Creation")
        bulk_layout = QVBoxLayout()

        # Account count
        count_layout = QHBoxLayout()
        self.account_count_spin = QSpinBox()
        self.account_count_spin.setRange(1, 100)
        self.account_count_spin.setValue(10)
        count_layout.addWidget(QLabel("Number of accounts:"))
        count_layout.addWidget(self.account_count_spin)
        count_layout.addStretch()
        bulk_layout.addLayout(count_layout)

        # Country selection
        country_layout = QHBoxLayout()
        self.country_combo = QComboBox()
        self.country_combo.addItems([
            "US - United States", "GB - United Kingdom", "DE - Germany",
            "FR - France", "IT - Italy", "ES - Spain", "BR - Brazil",
            "RU - Russia", "IN - India", "CA - Canada", "AU - Australia"
        ])
        country_layout.addWidget(QLabel("Country:"))
        country_layout.addWidget(self.country_combo)
        bulk_layout.addLayout(country_layout)

        # Phone provider
        provider_layout = QHBoxLayout()
        self.phone_provider_combo = QComboBox()
        self.phone_provider_combo.addItems([
            "sms-activate", "sms-hub", "5sim", "daisysms", "smspool", "textverified"
        ])
        provider_layout.addWidget(QLabel("Phone Provider:"))
        provider_layout.addWidget(self.phone_provider_combo)
        bulk_layout.addLayout(provider_layout)

        # Provider API key
        api_layout = QHBoxLayout()
        self.provider_api_edit = QLineEdit()
        self.provider_api_edit.setPlaceholderText("Your provider API key")
        self.provider_api_edit.setEchoMode(QLineEdit.EchoMode.Password)
        api_layout.addWidget(QLabel("Provider API Key:"))
        api_layout.addWidget(self.provider_api_edit)
        
        # Check Balance Button
        self.check_balance_button = QPushButton("Check Balance")
        self.check_balance_button.clicked.connect(self.check_provider_balance)
        self.check_balance_button.setObjectName("secondary")
        self.check_balance_button.setFixedWidth(120)
        api_layout.addWidget(self.check_balance_button)
        
        bulk_layout.addLayout(api_layout)
        
        # Balance Label
        self.balance_label = QLabel("Balance: --")
        self.balance_label.setStyleSheet("color: #b5bac1; font-weight: bold;")
        bulk_layout.addWidget(self.balance_label)

        # Setup Checklist
        checklist_group = QGroupBox("‚úÖ Setup Checklist")
        checklist_layout = QVBoxLayout()
        
        self.checklist_api_key = QLabel("‚ùå Provider API Key")
        self.checklist_api_key.setStyleSheet("padding: 4px;")
        checklist_layout.addWidget(self.checklist_api_key)
        
        self.checklist_proxies = QLabel("‚ùå Proxies (Required for 10+ accounts)")
        self.checklist_proxies.setStyleSheet("padding: 4px;")
        checklist_layout.addWidget(self.checklist_proxies)
        
        self.checklist_country = QLabel("‚úÖ Country Selected")
        self.checklist_country.setStyleSheet("padding: 4px;")
        checklist_layout.addWidget(self.checklist_country)
        
        self.checklist_anti_detection = QLabel("‚úÖ Anti-Detection Enabled")
        self.checklist_anti_detection.setStyleSheet("padding: 4px;")
        checklist_layout.addWidget(self.checklist_anti_detection)
        
        # Update checklist when fields change (only connect to existing widgets here)
        self.provider_api_edit.textChanged.connect(self._update_checklist)
        self.account_count_spin.valueChanged.connect(self._update_checklist)
        
        # Note: proxy_list_edit and randomize_fingerprint_checkbox connections
        # will be added after those widgets are created
        
        checklist_group.setLayout(checklist_layout)
        bulk_layout.addWidget(checklist_group)
        
        # Helpful info label
        help_label = QLabel(
            "üìã Quick Guide:\n"
            "‚Ä¢ For 1-9 accounts: Proxies optional but recommended\n"
            "‚Ä¢ For 10+ accounts: Proxies REQUIRED (1 per account ideal)\n"
            "‚Ä¢ Enable all anti-detection features for best results\n"
            "‚Ä¢ Monitor progress in the results section below"
        )
        help_label.setWordWrap(True)
        help_label.setStyleSheet("color: #7289da; padding: 8px; background: rgba(114, 137, 218, 0.1); border-radius: 4px;")
        bulk_layout.addWidget(help_label)

        # Control buttons
        control_layout = QHBoxLayout()
        self.start_creation_button = QPushButton("üöÄ Start Bulk Creation")
        self.start_creation_button.clicked.connect(self.start_bulk_creation)
        self.start_creation_button.setObjectName("success")
        self.start_creation_button.setToolTip("Start creating the specified number of accounts")
        control_layout.addWidget(self.start_creation_button)

        self.stop_creation_button = QPushButton("‚èπ Stop Creation")
        self.stop_creation_button.clicked.connect(self.stop_bulk_creation)
        self.stop_creation_button.setEnabled(False)
        self.stop_creation_button.setObjectName("secondary")
        self.stop_creation_button.setToolTip("Stop the current account creation process")
        control_layout.addWidget(self.stop_creation_button)

        bulk_layout.addLayout(control_layout)

        # Progress and status
        self.creation_progress = QProgressBar()
        self.creation_progress.setVisible(False)
        self.creation_progress.setFormat("Creating accounts: %v/%m (%p%)")
        bulk_layout.addWidget(self.creation_progress)

        self.creation_status = QLabel("Ready to create accounts")
        self.creation_status.setStyleSheet("font-weight: bold; padding: 5px;")
        self.creation_status.setWordWrap(True)
        bulk_layout.addWidget(self.creation_status)

        # Success/Failure summary
        self.creation_summary = QLabel("")
        self.creation_summary.setStyleSheet("font-weight: bold; padding: 5px;")
        self.creation_summary.setWordWrap(True)
        self.creation_summary.setVisible(False)
        bulk_layout.addWidget(self.creation_summary)

        # Progress tracking variables for account creation
        self.account_creation_current = 0
        self.account_creation_total = 0

        bulk_group.setLayout(bulk_layout)
        layout.addWidget(bulk_group)

        # Account Cloning Section
        clone_group = QGroupBox("Account Cloning (Advanced)")
        clone_layout = QVBoxLayout()

        # Clone username input
        clone_input_layout = QHBoxLayout()
        self.clone_username_edit = QLineEdit()
        self.clone_username_edit.setPlaceholderText("@username or username to clone")
        clone_input_layout.addWidget(QLabel("Clone from:"))
        clone_input_layout.addWidget(self.clone_username_edit)
        clone_layout.addLayout(clone_input_layout)

        # Clone options
        clone_options_layout = QVBoxLayout()

        self.clone_profile_checkbox = QCheckBox("Clone profile (name, bio, photo)")
        self.clone_profile_checkbox.setChecked(True)
        clone_options_layout.addWidget(self.clone_profile_checkbox)

        self.clone_settings_checkbox = QCheckBox("Clone privacy settings")
        self.clone_settings_checkbox.setChecked(True)
        clone_options_layout.addWidget(self.clone_settings_checkbox)

        self.clone_contacts_checkbox = QCheckBox("Add mutual contacts")
        self.clone_contacts_checkbox.setChecked(False)
        clone_options_layout.addWidget(self.clone_contacts_checkbox)

        clone_layout.addLayout(clone_options_layout)

        # Clone button
        self.clone_button = QPushButton("Clone Account")
        self.clone_button.clicked.connect(self.clone_account)
        self.clone_button.setObjectName("warning")
        clone_layout.addWidget(self.clone_button)

        clone_group.setLayout(clone_layout)
        layout.addWidget(clone_group)

        # Proxy Management Section
        proxy_group = QGroupBox("üîê Proxy Management (Required for 10+ Accounts)")
        proxy_layout = QVBoxLayout()

        # Proxy info banner
        proxy_info_banner = QLabel(
            "‚ö†Ô∏è IMPORTANT: For creating 10+ accounts, proxies are REQUIRED.\n"
            "Each account should ideally have a unique proxy to prevent detection.\n"
            "Format: ip:port or ip:port:username:password (one per line)"
        )
        proxy_info_banner.setWordWrap(True)
        proxy_info_banner.setStyleSheet("""
            background: rgba(250, 166, 26, 0.15);
            padding: 10px;
            border-radius: 6px;
            border-left: 3px solid #faa61a;
            font-weight: bold;
        """)
        proxy_layout.addWidget(proxy_info_banner)

        # Proxy list display
        proxy_info_label = QLabel("üìù Paste proxies below or load from file:")
        proxy_info_label.setWordWrap(True)
        proxy_layout.addWidget(proxy_info_label)

        # Proxy text area
        self.proxy_list_edit = QTextEdit()
        self.proxy_list_edit.setPlaceholderText(
            "Enter proxies one per line:\n"
            "192.168.1.1:8080\n"
            "192.168.1.2:8080:user:pass\n"
            "Or click 'Load from File' to import a text file"
        )
        self.proxy_list_edit.setMaximumHeight(120)
        proxy_layout.addWidget(self.proxy_list_edit)

        # Proxy buttons
        proxy_buttons_layout = QHBoxLayout()
        
        self.load_proxy_file_button = QPushButton("Load from File")
        self.load_proxy_file_button.clicked.connect(self.load_proxy_file)
        self.load_proxy_file_button.setObjectName("secondary")
        proxy_buttons_layout.addWidget(self.load_proxy_file_button)

        self.clear_proxies_button = QPushButton("Clear All")
        self.clear_proxies_button.clicked.connect(self.clear_proxy_list)
        self.clear_proxies_button.setObjectName("secondary")
        proxy_buttons_layout.addWidget(self.clear_proxies_button)

        proxy_buttons_layout.addStretch()
        proxy_layout.addLayout(proxy_buttons_layout)

        # Proxy count label
        self.proxy_count_label = QLabel("0 proxies loaded")
        self.proxy_count_label.setStyleSheet("font-weight: bold; color: #7289da;")
        proxy_layout.addWidget(self.proxy_count_label)

        # Update proxy count when text changes
        self.proxy_list_edit.textChanged.connect(self.update_proxy_count)
        
        # Now connect proxy_list_edit to checklist update (after widget is created)
        self.proxy_list_edit.textChanged.connect(self._update_checklist)

        proxy_group.setLayout(proxy_layout)
        layout.addWidget(proxy_group)

        # Anti-Detection Settings
        detection_group = QGroupBox("Anti-Detection Measures")
        detection_layout = QVBoxLayout()

        self.use_proxy_checkbox = QCheckBox("Use proxies for account creation (recommended)")
        self.use_proxy_checkbox.setChecked(True)
        self.use_proxy_checkbox.setToolTip("Each account will be assigned a permanent proxy from your list")
        detection_layout.addWidget(self.use_proxy_checkbox)

        self.randomize_fingerprint_checkbox = QCheckBox("Randomize device fingerprints")
        self.randomize_fingerprint_checkbox.setChecked(True)
        detection_layout.addWidget(self.randomize_fingerprint_checkbox)
        
        # Now connect randomize_fingerprint_checkbox to checklist update (after widget is created)
        self.randomize_fingerprint_checkbox.stateChanged.connect(self._update_checklist)

        self.realistic_timing_checkbox = QCheckBox("Use realistic account creation timing")
        self.realistic_timing_checkbox.setChecked(True)
        detection_layout.addWidget(self.realistic_timing_checkbox)

        self.vary_platform_checkbox = QCheckBox("Vary device platforms (Android/iOS)")
        self.vary_platform_checkbox.setChecked(True)
        detection_layout.addWidget(self.vary_platform_checkbox)

        detection_group.setLayout(detection_layout)
        layout.addWidget(detection_group)

        # Results Section
        results_group = QGroupBox("Creation Results")
        results_layout = QVBoxLayout()

        self.creation_results_text = QTextEdit()
        self.creation_results_text.setReadOnly(True)
        self.creation_results_text.setMaximumHeight(150)
        results_layout.addWidget(self.creation_results_text)

        results_group.setLayout(results_layout)
        layout.addWidget(results_group)

        layout.addStretch()
        return self._wrap_tab(
            content,
            "Account Factory",
            "Provision new Telegram identities via SMS providers, smart proxies, and hardened safety rails."
        )

    def check_provider_balance(self):
        """Check balance for the selected SMS provider."""
        provider = self.phone_provider_combo.currentText()
        api_key = self.provider_api_edit.text().strip()
        
        if not api_key:
            QMessageBox.warning(self, "Missing API Key", "Please enter an API key.")
            return
            
        self.balance_label.setText("Checking balance...")
        self.check_balance_button.setEnabled(False)
        
        # Use APIKeyManager to check balance
        try:
            # We need to run async in a sync context
            # We'll use the main window's event loop via QTimer or similar if available
            # But since we are in a dialog, we might not have easy access to async runner
            # We'll use a QThread or a simple hack with asyncio.run if not in loop, but we ARE in Qt loop.
            # Best way: Use APIKeyManager in a worker thread or just use requests synchronously here for simplicity
            # since APIKeyManager is async.
            
            # Let's use a temporary sync request for simplicity here, duplicating logic slightly 
            # OR better, wrap async call.
            
            import requests
            
            balance = None
            error = None
            
            # Simple sync check based on provider
            try:
                if provider == 'sms-activate':
                    params = {'api_key': api_key, 'action': 'getBalance'}
                    resp = requests.get('https://api.sms-activate.org/stubs/handler_api.php', params=params, timeout=10)
                    if resp.status_code == 200 and 'ACCESS_BALANCE' in resp.text:
                        balance = resp.text.split(':')[1]
                elif provider == 'sms-hub':
                    params = {'api_key': api_key, 'action': 'getBalance'}
                    resp = requests.get('https://smshub.org/api.php', params=params, timeout=10)
                    if resp.status_code == 200 and 'ACCESS_BALANCE' in resp.text:
                        balance = resp.text.split(':')[1]
                elif provider == '5sim':
                    headers = {'Authorization': f'Bearer {api_key}', 'Accept': 'application/json'}
                    resp = requests.get('https://5sim.net/v1/user/profile', headers=headers, timeout=10)
                    if resp.status_code == 200:
                        balance = str(resp.json().get('balance', 0))
                elif provider == 'daisysms':
                    headers = {'Authorization': f'Bearer {api_key}'}
                    resp = requests.get('https://api.daisysms.com/v1/balance', headers=headers, timeout=10)
                    if resp.status_code == 200:
                        balance = str(resp.json().get('balance', 0))
                elif provider == 'smspool':
                    headers = {'Authorization': f'Bearer {api_key}'}
                    resp = requests.get('https://api.smspool.net/me', headers=headers, timeout=10)
                    if resp.status_code == 200:
                        balance = str(resp.json().get('balance', 0))
                elif provider == 'textverified':
                    headers = {'Authorization': f'Bearer {api_key}'}
                    resp = requests.get('https://www.textverified.com/api/me', headers=headers, timeout=10)
                    if resp.status_code == 200:
                        balance = str(resp.json().get('balance', 0))
            except Exception as e:
                error = str(e)
                
            if balance is not None:
                self.balance_label.setText(f"Balance: {balance}")
                self.balance_label.setStyleSheet("color: #23a559; font-weight: bold;")
                # Also save the key if valid
                # self.api_key_manager.add_api_key(provider, api_key) 
            else:
                self.balance_label.setText("Check failed")
                self.balance_label.setStyleSheet("color: #f23f42; font-weight: bold;")
                if error:
                    logger.error(f"Balance check error: {error}")
                    
        except Exception as e:
            logger.error(f"Error checking balance: {e}")
            self.balance_label.setText("Error")
            
        self.check_balance_button.setEnabled(True)
